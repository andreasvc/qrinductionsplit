\documentclass{article}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage[pdftex]{graphicx}
\usepackage[english]{babel}
\usepackage[colorlinks=true, linkcolor=black, urlcolor=blue, pdfborder={0 0 0}]{hyperref}
%\usepackage{synttree}
%\usepackage[utf8x]{inputenc}

\title{Model Induction in Qualitative Reasoning}
\author{Andreas van Cranenburgh \\ 0440949 \\ acranenb@science.uva.nl 
\and Hanne Nijhuis \\ 0364568 \\ hnijhuis@science.uva.nl}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}

\section{Literature Review}
In this section we will review a few of the papers that have contributed
greatly to the definition of Qualitative Reasoning. We will give a short
summary of the papers and will conclude with an overview of the current field
of research and possible future work.

\subsection{Qualitative Reasoning}
The following papers describe the foundations of qualitative reasoning.

\subsubsection{A qualitative Physics based on confluences (de Kleer \& Brown)}

\cite{kleer} present a framework for formalizing physics in a qualitative
rather than quantitative manner. Whereas physicists describe the world in terms
of continuous differential equations, the rest of the world uses an implicit
psychological model of naive physics. The framework of \cite{kleer} falls between
these two extremes of precision and informality. Although their framework is completely
qualitative, as opposed to standard physics, on the other hand their framework
is formal in the sense of explicitly defining causal and structural relations, as opposed
to the psychological models of humans (presumably).

This approach is presented as being useful for physics education, expert
systems and even physics, in that it explicitly deals with causality. The
latter is in contrast with standard physics, in which laws are merely
correlations without exceptions.

% more to come.

\subsubsection{Qualitative Process Theory (Forbus)}

\subsubsection{Garp3 - Workbench for Qualitative Modelling and Simulation (Bredeweg et al.)}

\subsection{Automated Modeling}

To introduce the recent developments in the field of automated modelling we
will now review a few papers on this topic.

\subsubsection{Automated modeling in process-based qualitative reasoning
(Buisman)}
The concept of automated modeling was introduced by Buisman \cite{buisman} in
2007. He motivates the research with the goal to relieve the strain placed on
experts and to speed up the modelling process. The approach he took however,
does not provide in these goals yet, but is more of an exploration of the
possibilities of using Artificial Intelligence to induce models based on
behavior graphs. We will give a short overview of the algorithm he developed.

The input for the algorithm consists of:
\begin{itemize}
\item State-graph (states and state transitions)
\item Scenario (partial information about structural relations between entities)
\item ISA-hierarchy (full description of entity type hierarchy)
\end{itemize}
With this input, the algorithm produces models which are ready for simulation as
output.

There are certain constraints on the input. The \emph{full envisionment}
requirement means that the behavior is known for all possible initial values for
all quantities in the system. Also, the derivatives and amounts have to be
defined for every state. Finally, the input data can not contain any noise.

The algorithm start with searching for so called \emph{naive dependencies},
which are dependencies that are consistent with the entire state-graph. They are
found by applying consistency rules on all pairs of quantities. These
consistency rules consider the amount and derivative values of the quantities
for all states and therewith induce possible dependencies. For example, a
 positive influence between $Q_1$ and $Q_2$ could exist if for every state 
 $A_s(Q_1) = D_s(Q_2)$.
There will be redundancy in the set of naive dependencies which has to be pruned
by filtering out substitutionary groups. %HAVE TO REWRITE THIS!!
 

\subsubsection{Jochem}
%less brute force, instead attempt to find the conceptually correct model immediately

\subsubsection{Carsten}
Causal groups % feedback loops, interacting processes

\subsection{Overview}
%overview of what?

\section{Theory}

In the field of QR, models %( / scenario's / systems ?) 
consist of
several smaller fragments which can be roughly divided in three categories:
static, process and agent. This categorization is not strict, but gives
a certain view on how things work. Static fragments are used to describe the
structure of a model, as well as proportionalities between quantities. A static
fragment cannot have any agents or influences in it. A \emph{process} fragment
should have at least one direct influence and is not restricted in terms of dependencies. %(relations?)
Finally, \emph{agent} fragments should be used to describe any influences on a
system that are external, hence not part of the system itself.

Fragments can be useful to make the complete system more comprehensible -- ie., they are a form of chunking. 
Also, while building these complex models, fragments allow the user to focus on
what happens in a small part of the model, without having to worry about the
other 'components'. For example in a model describing a population, seperate
fragments could describe processes like birth, death, emigration, etc.

Recent work on automated modeling \cite{buisman, vanweelden, liem} has focused
on generating a correct model based on a full-envisionment behavior graph. The
current algorithms always produce a single model fragment which describes the
complete system. The useful fragmentation of a system is hereby lost and
comprehending the output could become quite difficult with large models. We
therefore introduce a way of splitting such a single monolithic model into
smaller fragments while preserving the exact same behavior.

\section{Approach}
In this section we describe our approach on inducing model fragments.

\subsection{Monolithic model}

We take a monolithic model and divide it into several smaller fragments. To do
so, we need to comply to several requirements:

\begin{itemize}
\item all dependencies have to be retained

\item the behavior has to be reproducable

\item 

\end{itemize}

\subsection{Algorithm}

\begin{itemize}

\item Find a list of pivots, conditions on which the model fragments are based.
Currently these are single structural relations.

\item For each pivot, find a set of dependencies which apply whenever the pivot
is present, without exception

\item Generalize these dependencies into a single model fragment, several
dependencies among instances may be compressed into one

\end{itemize}

\section{Experiments \& Results}
\subsection{Evaluated Models}

% paste some output here, take screenshots or save EPS files from Garp3

\subsubsection{Tree and shade growth} 
% maybe show scenario with three trees, number of model fragments should stay the same! proof of concept.

\begin{verbatim}
Input: 
[dependency(inf_pos, growth_rate1, size1), 
dependency(prop_pos, size1,growth_rate1), 
dependency(prop_pos, size1, shade1),
dependency(q_correspondence, size1, shade1), 
dependency(q_correspondence, shade1, size1)]

Set of struct rels: 
[ (self, size, size), (self, shade, size), (self, shade, shade), 
(self, growth_rate, size), (self, growth_rate, shade), 
(self, growth_rate, growth_rate)]

Fragments (2): 
[ (self, shade, size), 
	dependency(prop_pos, size, shade),
	dependency(q_correspondence, size, shade), 
	dependency(q_correspondence, shade, size)] 
[ (self, growth_rate, size),
	dependency(inf_pos, growth_rate, size),
	dependency(prop_pos, size, growth_rate)]

Unfragment: []
\end{verbatim}

\subsubsection{Stacked bath tubs}

\begin{verbatim}
Input: 
[dependency(inf_pos, flow12, level12), 
dependency(inf_pos, flow11, level11), 
dependency(inf_neg, flow12, level11), 
dependency(prop_pos, level11, flow12), 
dependency(q_correspondence, level11, flow12)]

Set of struct rels: 
[ (self, flow, flow), (self, level, level), (in, flow, level), 
(out, flow, level)]

Fragments (2): 
[ (in, flow, level), dependency(inf_pos, flow, level)]
[ (out, flow, level), 
	dependency(inf_neg, flow, level), 
	dependency(prop_pos, level, flow), 
	dependency(q_correspondence, level, flow)]

Unfragment: []
\end{verbatim}

\subsubsection{Communicating vessels} 
%both two and three? maybe also the truly compositional one?
Two communicating vessels:

\begin{verbatim}
Input: 
[dependency(inf_pos, flow3, amount5), 
dependency(inf_neg, flow3, amount4), 
dependency(prop_neg, flow3, pressure5), 
dependency(prop_pos, flow3, pressure4), 
dependency(prop_pos, height4, amount4), 
dependency(prop_pos, height5, amount5), 
dependency(prop_pos, pressure5, height5), 
dependency(prop_pos, pressure4, height4), 
dependency(q_correspondence, height5, amount5), 
dependency(q_correspondence, pressure4, height4), 
dependency(q_correspondence, pressure5, height5), 
dependency(q_correspondence, height4, amount4), 
dependency(equals, flow3, min(pressure4, pressure5)), 
dependency(equals, height4, pressure4), 
dependency(equals, height5, pressure5)]

Set of struct rels: 
[ (self, flow, flow), (self, amount, amount), (self, amount, height), 
(self, amount, pressure), (self, height, height), (self, height, pressure),
(self, pressure, pressure), (from, amount, flow), (from, height, flow), 
(from, pressure, flow), (to, flow, amount), (to, flow, height), 
(to, flow, pressure)]

Fragments (6):
[ (self, amount, height), 
	dependency(prop_pos, height, amount), 
	dependency(q_correspondence, height, amount)]
[ (self, height, pressure), 
	dependency(prop_pos, pressure, height), 
	dependency(q_correspondence, pressure, height), 
	dependency(equals, height, pressure)]
[ (from, amount, flow), dependency(inf_neg, flow, amount)]
[ (from, pressure, flow), dependency(prop_pos, flow, pressure)]
[ (to, flow, amount), dependency(inf_pos, flow, amount)]
[ (to, flow, pressure), dependency(prop_neg, flow, pressure)]

Unfragment: [dependency(equals, flow3, min(pressure4, pressure5))]
\end{verbatim}

Three communicating vessels.

\begin{verbatim}
Input:
[dependency(inf_pos, flow3, amount5), 
dependency(inf_neg, flow3, amount4), 
dependency(prop_neg, flow3, pressure5), 
dependency(prop_pos, flow3, pressure4), 
dependency(prop_pos, height4, amount4), 
dependency(prop_pos, height5, amount5), 
dependency(prop_pos, pressure5, height5), 
dependency(prop_pos, pressure4, height4), 
dependency(q_correspondence, height5, amount5), 
dependency(q_correspondence, pressure4, height4), 
dependency(q_correspondence, pressure5, height5), 
dependency(q_correspondence, height4, amount4), 
dependency(equals, flow3, min(pressure4, pressure5)), 
dependency(equals, height4, pressure4), 
dependency(equals, height5, pressure5), 
dependency(inf_pos, flow4, amount6), 
dependency(inf_neg, flow4, amount5), 
dependency(prop_neg, flow4, pressure6), 
dependency(prop_pos, flow4, pressure5), 
dependency(prop_pos, height6, amount6), 
dependency(prop_pos, pressure6, height6), 
dependency(q_correspondence, height6, amount6), 
dependency(q_correspondence, pressure6, height6), 
dependency(equals, flow4, min(pressure5, pressure6)), 
dependency(equals, height6, pressure6)]

Set of struct rels: 
[ (self, flow, flow), (self, amount, amount), (self, amount, height), 
(self, amount, pressure), (self, height, height), (self, height, pressure),
(self, pressure, pressure), (from, amount, flow), (from, height, flow), 
(from, pressure, flow), (to, flow, amount), (to, flow, height), 
(to, flow, pressure)]

Fragments (6):
[ (self, amount, height), 
	dependency(prop_pos, height, amount), 
	dependency(q_correspondence, height, amount)]
[ (self, height, pressure), 
	dependency(prop_pos, pressure, height), 
	dependency(q_correspondence, pressure, height), 
	dependency(equals, height, pressure)]
[ (from, amount, flow), dependency(inf_neg, flow, amount)]
[ (from, pressure, flow), dependency(prop_pos, flow, pressure)]
[ (to, flow, amount), dependency(inf_pos, flow, amount)]
[ (to, flow, pressure), dependency(prop_neg, flow, pressure)]

Unfragment:
[dependency(equals, flow3, min(pressure4, pressure5)), 
dependency(equals, flow4, min(pressure5, pressure6))]
\end{verbatim}


\subsubsection{Population dynamics}
%single population? split into birth, migration etc.
%interacting populations? but ants garden is too much

\section{Future work}

% World domination etc.

\section{Conclusion}



\begin{thebibliography}{99}

% 1,5 - 2 pp. per artikel

%allebei
\bibitem{bredeweg-eco} Bredeweg, B. and Salles, P. (2009), Handbook of
Ecological Modelling, Chapter 19 - Mediating conceptual knowledge using
qualitative reasoning. In: J\/orgen, S.V., Chon, T-S., Recknagel, F.A. (Eds.),
Handbook of Ecological Modelling and Informatics. Wit Press, Southampton, UK,
pp. 351.398.

%allebei
\bibitem{bredeweg-garp} Bredeweg, B., Linnebank, F., Bouwer, A. and Liem, J.
(2009) 02 Bredeweg EtAl ECOINF 2009.pdf (598.325 Kb) Garp3 - Workbench for
Qualitative Modelling and Simulation. Ecological Informatics 4(5-6), 263-281.

%hanne
\bibitem{forbus} Forbus, K.D. (1984) Forbus1984.pdf (4.108 Mb) Qualitative
process theory. Artificial Intelligence, 24:85-168. 

%andreas
\bibitem{kleer} Kleer, J. de and Brown J.S. (1984) deKleerBrown1984.pdf (4.005
Mb) A qualitative Physics based on confluences, Artificial Intelligence,
24:7-83 (for the course you may ignore section 6)

%andreas
\bibitem{cioaca} Cioaca, Linnebank, Bredeweg, Salles 2009 Cioaca EtAlECOINF
2009.pdf (1,001.442 Kb) A qualitative reasoning model of algal bloom in the
Danube Delta Biosphere Resere (DDBR) in: ecological informatics 4 (2009)
p282-298

%hanne
\bibitem{buisman} Buisman, H., \emph{Automated modeling in process-based
qualitative reasoning}
\url{http://staff.science.uva.nl/~bredeweg/pdf/BSc/20062007/Buisman.pdf}

% (samenvatting van Buisman plus verbeteringen)
%hanne 
\bibitem{liem} Liem, J., Buisman, H. and Bredeweg, B., \emph{Supporting
Conceptual Knowledge Capture Through Automatic Modelling}

%hanne
\bibitem{vanweelden} van Weelden, C., \emph{Automated modeling of conceptual
knowledge}
\url{http://staff.science.uva.nl/~bredeweg/pdf/BSc/20082009/vanWeelden.pdf}

\end{thebibliography}

\end{document}

----------------------------------------------

Notes

    * For the stacked bath tub model we changed the quantity-space of flow to ZPM (instead of ZP) because then we could replace the value-correspondences by a single Q-correspondence..
    * To be able to intergrate the splitting into the AM we need full scenario because we need all information about entities and quantities (we've entered them by hand for now..)

Ideas

    * done: split code for model output into generation & garp adding
    * current: compositional model fragments (also: accept existing model fragments as input)
    * deferred: lift full envisionment requirement, accept negative input (eg. list of impossible value combinations).
    * deferred: user interaction: graphical dialog to choose best model in case of ambiguity

----------------------------------------------
Todos

    * done: fix influences
    * done: fix output of models to garp. deferred: each possible model should become a model fragment (too much ambiguity)
    * done: split into multiple model fragments: working code: qrsplit
    * done: collapse similar model fragments into generic model fragments (eg. Faucet1 =>I+ Bath1 and Faucet2 => I+ Bath2 becomes Faucet =>I+ Bath)
    * done: detect necessary structural relations / other conditions required to make a model fragment generic.
    * distinguish between static (no influences) & process; filter current list of fragments and split them in a static and a process list.
    * integrate code with model induction (input) & garp (output)
    * try other models listed in van Weelden & Buisman. notably, communicating vessels

    * report: Intro - Summary per paper (literature review) - Discussion - Conclusion - Project - Theoretical / Practical / Technical Perspectives * further details: blackboard

----------------------------------------------

Minutes
April 13th 2010

New plan:

    * Some sort of standard for what a well-formed fragment should be
    * -- Static vs process fragments?
    * -- Everything per entity 1 fragment?
    * -- Things like 'birth', 'death', 'emigration' and 'immigration'?
    * -- Influences?

    * We need some sort of evaluation to check our models against.

    * First run a the models we want to use and analyze their current output, compare them to our 'ideal' output.
    * We should not worry about intergration with the current Automatic Modeling code for now. First focus on hand-corrected input.
    * Recognizing duplicate (super)cluster could be a nice step to start with.. to get working on the code.

Notes:

    * Influences: now written to screen --> should be asserted
    * I's wrong direction? (inf-pos-a-b = b --> a)
    * naive dependencies: exponential
    * Communicating vessels: hack in causal groups: same entities (same_object_group/2)
    * Choose hacks for conceptually best model

    * Discussed with Floris that finding correspondences could be done faster by first looking for them without considering naive_dependencies yet.


